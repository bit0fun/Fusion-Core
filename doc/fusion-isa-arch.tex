\documentclass[letterpaper, 11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{inconsolata}
\usepackage{fontspec}
\defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
\setmainfont{Hack}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage[left=1in, right=1in, top=1.00in, bottom=1.00in]{geometry}
\usepackage{subfigure}
\usepackage{hyperref}
\usepackage{amssymb}
\hypersetup{colorlinks=false,linktoc=all}


\title{Fusion-Core ISA Definition: Revision 0.1}
\author{Dylan Wadler}

\begin{document}
\maketitle
\newpage
\tableofcontents


\newpage
\part{Administrative}
\section{Change log}
\paragraph{Version 0.1} Initial Definition of the Instruction Set Architecture

\section{Introduction}

\subsection{About}
\paragraph{Introduction}The Fusion-Core ISA is dedicated to creating an easily expandible architecture without having to 
recompile a program's binary. By use of defining an easy interface with a simple core instruction set, this allows for
more freedom in implementation. High end processors and microcontrollers would only require slight varaitions in
configuration, as their core would remain identical save for easy to maintain and scalable co-processors.
\paragraph{Main Ideas}The architecture is Big endian, with a core instruction set that is RISC, but the co-processors do not need to adhere to the RISC philosophy. This allows for more flexibility in design, and possibly faster core clock speeds as the pipeline would depend on smaller amounts of logic. Only the instructions provided in this document are to be implemented in the main processor. The co-processors defined in this document are recommended, but not required for normal function. Co-processor documentation is to be provided by the creator, and should adhere to the standards of clarity and conciseness such that it can be easily implemented from the documentation alone in a HDL. 
\paragraph{64 Bit instructions:}At this moment in time, the Fusion-Core ISA is only a 32 bit ISA. Due to the focus on co-processors,
older implementations could easily be modified to include 64 bit operations.
\paragraph{Co-Processors}The Co-Processor interface is currently defined by setting the MSB within the OP Code field of 
an instruction, to decrease complexity of the Decode unit. In doing so, this allows for coprocessor code to be written in the same memory space as the main processor code. In the current iteration, up to 32 different coprocessors can be used, with the option for dynamic or static allocation of the OP Codes. The interface for the coprocessors is explained further in the dedicated section.

\subsection{Goals}
\paragraph{}The main goal is to provide an architecture with a simple decoding unit and the ability to utilize a single binary for all implementations of the architecture.
\subsection{Conventions}
\paragraph{Document Conventions:}Example code will be shown with \texttt{monospace} text. General purpose registers will be denoted with
\$R\# where \# is the number of the register. Special purpose registers will be written with \textbf{bold} text.
%\paragraph{Naming Conventions:}The name of input signals will have "\_in" after the signal name, with "\_out" after output signals.
%This is mainly used in the verilog example implementation. If a naming convention is not globally used, it will be stated in the individual section that it pertains to. 

\part{Programming Information}
\section{Register File Definitions}
\paragraph{}This section goes over the different registers available in the ISA. Each register file name begins with 
"REGF", such as the first General Purpose Register File being REGFGP0. Any additional register files require the number after the
name of the register file. Register files with additional numbers after them are bank switched to reduce space, hence why the number is
required to denote the register file space used.
\paragraph{}To alleviate context switching delays, three general purpose register files are bank availble by bank switching. Only these register files are required
for a minimal system, though more can certainly be implemented if required. Each register file can be accessed by changing the value in the BSELRF register. 
\subsection{Register File List}
\begin{figure}[!h]
	\caption{General Purpose Registers}
	%	\begin{center}
	\parbox{0.5\linewidth}{
		\centering
		\fontsize{6}{8}\selectfont
		\begin{tabular}{|l|l|}
			\hline
			\multicolumn{2}{|c|}{REGFGP0} \\
			\hline
			Register & Register Name \\ \hline
			\$R0  & ZERO \\ 	\hline
			\$R1  & SP \\ 	\hline
			\$R2  & FP \\ 	\hline
			\$R3  & GP \\ 	\hline
			\$R4  & RA \\ 	\hline
			\$R5  & ARG0 \\ 	\hline
			\$R6  & ARG1 \\ 	\hline
			\$R7  & ARG2 \\ 	\hline
			\$R8  & ARG3 \\ 	\hline
			\$R9  & RVAL0 \\ 	\hline
			\$R10 & RVAL1 \\ \hline
			\$R11 & GR0  \\ \hline
			\$R12 & GR1  \\ \hline
			\$R13 & GR2  \\ \hline
			\$R14 & GR3  \\ \hline
			\$R15 & GR4  \\ \hline
			\$R16 & GR5  \\ \hline
			\$R17 & GR6  \\ \hline
			\$R18 & GR7  \\ \hline
			\$R19 & GR8  \\ \hline
			\$R20 & GR9  \\ \hline
			\$R21 & GR10  \\ \hline
			\$R22 & TMP0  \\ \hline
			\$R23 & TMP1 \\ \hline
			\$R24 & TMP2  \\ \hline
			\$R25 & TMP3  \\ \hline
			\$R26 & TMP4  \\ \hline
			\$R27 & TMP5  \\ \hline
			\$R28 & TMP6  \\ \hline
			\$R29 & TMP7  \\ \hline
			\$R30 & HI0  \\ \hline
			\$R31 & LOW0  \\ \hline
		\end{tabular}
	}
	\hfill
	\parbox{0.5\linewidth}{
		\centering\fontsize{6}{8}\selectfont
		\fontsize{6}{8}\selectfont
		\begin{tabular}{|l|l|}
			\hline
			\multicolumn{2}{|c|}{REGFSYSCL0} \\
			\hline
			Register & Register Name \\ \hline
			\$R0  & ZERO \\ 	\hline
			\$R1  & SP1 \\ 	\hline
			\$R2  & FP1 \\ 	\hline
			\$R3  & GP1 \\ 	\hline
			\$R4  & RA1 \\ 	\hline
			\$R5  & SYSARG0 \\ 	\hline
			\$R6  & SYSARG1 \\ 	\hline
			\$R7  & SYSARG2 \\ 	\hline
			\$R8  & SYSARG3 \\ 	\hline
			\$R9  & SYSARG4 \\ 	\hline
			\$R10 & SYSARG5 \\ \hline
			\$R11 & SYSRVAL0  \\ \hline
			\$R12 & SYSRVAL1  \\ \hline
			\$R13 & SYSRVAL2  \\ \hline
			\$R14 & SYSRVAL3  \\ \hline
			\$R15 & SYSRVAL4  \\ \hline
			\$R16 & GPR0  \\ \hline
			\$R17 & GPR1  \\ \hline
			\$R18 & GPR2  \\ \hline
			\$R19 & GPR3  \\ \hline
			\$R20 & GPR4  \\ \hline
			\$R21 & GPR5  \\ \hline
			\$R22 & GPR6  \\ \hline
			\$R23 & GPR7  \\ \hline
			\$R24 & SYSTMPR0  \\ \hline
			\$R25 & SYSTMPR1  \\ \hline
			\$R26 & SYSTMPR2  \\ \hline
			\$R27 & SYSTMPR3  \\ \hline
			\$R28 & SYSTMPR4  \\ \hline
			\$R29 & SYSTMPR5  \\ \hline
			\$R30 & SYSREGHI0  \\ \hline
			\$R31 & SYSREGLOW0  \\ \hline
		\end{tabular}
	}
	%		\end{center}
\end{figure}


\begin{figure}
	
	\caption{Special Registers}
	\begin{center}
		\fontsize{6}{8}\selectfont
		\begin{tabular}{|l|l|l|l|}
			\hline
			\multicolumn{4}{|c|}{System Registers} \\
			\hline
			Register Name & Description & Width (bytes) &Address (Hex) \\ \hline
			CPUREV  & CPU Revision 				 & 	1		& 0x00000000\\ 	\hline
			CPNUM	& Co-Processor Number		 &	1		& 0x00000001\\	\hline
			CPO0  	& Co-Processor 0 ID 		 & 	2		& 0x00000002\\ 	\hline
			CPO1  	& Co-Processor 1 ID 		 &	2		& 0x00000004\\ 	\hline
			CPO2  	& Co-Processor 2 ID 		 &	2		& 0x00000006\\ 	\hline
			CPO3  	& Co-Processor 3 ID 		 &	2		& 0x00000008\\ 	\hline
			STAT	& Status Register			 &	1		& 0x0000000a \\ 	\hline
			n/a		& RESERVED				 	 &	1		& 0x0000000b \\ \hline
			OPCAR	& Opcode Allocation Pointer	 &	4		& 0x0000000c \\ \hline
			
		\end{tabular}
	\end{center}
\end{figure}

\begin{figure}
	\caption{Supervisor Registers}
	
	\begin{center}
		\fontsize{6}{8}\selectfont
		\begin{tabular}{|l|l|l|}
			\hline
			\multicolumn{3}{|c|}{Supervisor Registers} \\
			\hline
			Register Name & Description & Address (Hex)\\ \hline
			SMSTAT & Supervisor mode status register & 0x00000000 \\ 	\hline
			PRCPR0 & Process Pointer register 0 	 & 0x00000004	\\ \hline 
			HTINFO & Hardware Thread Info 			 & 0x00000008 \\ \hline
			HTCTL  & Hardware Thread Control		 & 0x0000000c \\ \hline
		\end{tabular}
	\end{center}
	
\end{figure}
\subsection{General Purpose Registers}
\paragraph{}32 general purpose registers that are 32 bits wide are available, as shown in Figure 1, in the previous section. 
There is a distinction between the System Register File and the General Purpose Register File, as during certain syscall
instructions, the register files are bank switched. Only GP0 through GP7 are saved, for passing between the different banks. 

\paragraph{}While it is not defined by the architecture, larger general purpose registers can be used instead of 32 bit wide registers. The System Register File allows 8 bit addressing for the registers to be accessed, in order to utilize more of the memory space.
If larger registers are needed, consider using a co-processor to for instructions that require larger operands. 
This provides code compatibility between different implementations.
\subsection{Special Registers}
\paragraph{}The special registers are sorted between the System Registers and the Supervisor Registers. The system registers provide
simple configuration values and some read-only registers to give the programmer information about the implementation.
The registers defined in this manual are the bare minimum special purpose registers, and
should be included for code compatibility. \\
The supervisor registers are aimed at higher level functions required for operating system environments. They are not essential for operation,
and can either be partially implemented or not at all. The optional parts will be noted in the register descriptions.\\

\subsection{Special Purpose Registers}
\subsubsection{System Registers}
%STAT register START
\begin{center}
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
	%	\hline
			\multicolumn{8}{c}{\textbf{STAT}: Status Register} \\ \hline
		 	7 & 6  &  5   &	4	 &	3	&	2  &	1 &	0 \\ \hline
			Z & OV & PEMA & PML2 & PML1 & PML0 & INTN & SPCP  \\ \hline
		
	\end{tabular}
\end{center}

\begin{tabular}{l l}
	STAT	& Read only register for various processor state information. The flags are \\
	\hfill 	& explained in detail below. \\
	Z		& Zero Flag; Indicates whether the processed instruction's resulted in zero. Read Only\\
	\hfill	& The flag is set to 0 when the ALU calculation is 0, and 1 when the output it non-zero. \\
	OV		& Overflow Flag; Indicated whether the processed instruction's result \\
	\hfill	& overflowed the 32 bit space. Read only. \\
	\hfill	& The overflow flag is set to the output of the carry out of the ALU. \\
	\hfill  & With addition, this would set the bit to a 1 when true. \\
	\hfill	& For subtraction, the inverse is true. \\ 
	PML 	& Permission Level; Inidcates the running process' permission level. Read only.\\
			%	The three registers, PML2, PML1 and PML0 are used to generate a 3 bit value to determine the permission level. The following
		%		denotes the different states with PML1 being the left bit, and PML0 being the right bit. \\
	\hfill	&	\begin{tabular}{l|l}
			PML & Description \\ \hline
			000 & Low User Level \\
			001 & High User Level \\
			010 & Low Supervisor Level \\
			011 & High Supervisor Level \\
			100 & Low Hypervisor Level \\
			101 & High Hypervisor Level \\
			110 & Reserved \\
			111 & Top Hypervisor Level  \\
	\end{tabular}\\
	\hfill & The permission levels are explained in more detailed in their dedicated section.\\
	PEMA   & Permission Accepted; Indictates whether a privaledged systemcall request was accepted. Read only \\
	INTN   & Interrupt Enable; Indicates whether interrupts are enabled. Read/Write \\ 
	SPCP   & Support CoProcessors; Indicates whether co-processor code is recognized as \\
	\hfill & illegal instruction or microcode operation. \\
	\hfill & Read/Write. \\

\end{tabular}
\paragraph{} In order to write to this register, the bits that are read only can be set to any value. \\
\paragraph{Optionality} In the event that the permission levels are not needed, they should be hard coded to 0x7, the
highest permission level to avoid porting code. PEMA should also be hardcoded to a logic high for the same reasons stated.\\
\begin{center}
	\line(1,0){250}
\end{center}

%STAT register END
\subsubsection{Supervisor Registers}

\section{Permission Levels}
\subsection{User Levels}
\subsubsection{Low User Level} User space programs are designed to run in this permission level. Write access to supervisor registers is revoked.
\subsubsection{High User Level}

\subsection{Supervisor Levels}
\subsubsection{Low Supervisor Level}
\subsubsection{High Supervisor Level}

\subsection{Hypervisor Levels}
\subsubsection{Low Hypervisor Level}
\subsubsection{High Hypervisor Level}
\subsubsection{Top Hypervisor Level}

\section{Memory}
\paragraph{}At this point in time, the ISA only handles 32 bit addresses.
With memory capacity increasing in size as time goes on, this may change. %In order to access 
%larger sections of memory, the use of an offset register may be implemented to create 64 bit addresses.
%The use of virtual memory with said offset register is also accepted.

\subsection{Memory Locations for Vector Table}
\subsubsection{Interrupt Vector Table}
\subsubsection{Exception Vector Table}


\begin{figure}[!h]
	\begin{center}
		\begin{tabular}{|l|l|}
			\hline
			Address (32 bit) &  Definition\\ \hline
			0x0000 & Reset \\ 	\hline
			0x0004 & Co-Processor Microcode Exception \\ 	\hline
			0x0008 &  \\ 	\hline
			0x000c &  \\ 	\hline
			0x0010 &  \\ 	\hline
			0x0014 &  \\	\hline
		\end{tabular} 
		\caption{Exception Vector Table}
	\end{center}
	
\end{figure} 

\begin{center}
	\line(1,0){250}
\end{center}

\clearpage

\part{Instructions}
\section{Instruction Definitions}
\subsection{Instruction Format Types}
\paragraph{}This section will talk about the different instructions available in the core processor, their encodings, function, and hazards
they cause or registers they affect in the processor. The Co-Processor instructions are purlely generic and allow the implementation of
each Co-Processor to determine how their respective instructions will be decoded. Only the Operation Codes will be defined for each 
Co-Processor slot to allow for more customization.

\newpage
\subsubsection{Integer}
\paragraph{}The interger instructions are the heart of this processor's arithmetic abilities and is vital to ensure fast execution. A semi-strict
adherence to RISC philosophy in this architecture is required to exploit any benefits to this ISA in a real implementation.
\paragraph{}The integer instruction coding with descriptions, is shown in the diagrams below.

\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
			\multicolumn{6}{c}{Register/Integer Instruction Format}\\ \hline
				\hspace{2pt} opcode (0x01) \hspace{2pt} & \hspace{5pt} rd \hspace{5pt} &  \hspace{4pt} rsa \hspace{4pt} & \hspace{4pt}rsb  \hspace{4pt}& \hspace{10pt}shft  \hspace{10pt} & \hspace{3pt} aluop \hspace{3pt}   \\	\hline
			31 \hfill 26& 25 \hfill 21 &20 \hfill  16& 15 \hfill  11&10 \hfill   4&3 \hfill   0\\ \hline
		
	\end{tabular}
\end{center}	
\paragraph{Overview:}The Register/Integer Instruction Format is for basic ALU operations, without immediates. Registers RSa and RSb are the two operands,which
are stored in register Rd. The 4 bit ALUOP field denotes the settings for the ALU, to reduce complexity of selecting what operation to choose.
The shft bits are only for the shift amount with the shifting instructions, but unused for other instructions. 
\paragraph{}The following instructions use this encoding:\\
\begin{center}
%	\begin{tabular}{|c|c|c|} \hline
	\begin{longtable}{|l|l|l|}\hline
			Instruction & Description 				& ALU Operation (hex) \\ \hline
			add			& Add 						& 0x0 \\ \hline
			sub 		& Subtract					& 0x1 \\ \hline
			addu 		& Add Unsigned 				& 0x2 \\ \hline
			subu		& Subtract Unsigned 		& 0x3 \\ \hline
			tcmp		& 2's Complement			& 0x4 \\ \hline
			and			& And						& 0x5 \\ \hline
			or			& Or						& 0x6 \\ \hline
			xor			& Exclusive Or				& 0x7 \\ \hline
			sal			& Arithmetic Shift Left		& 0x8 \\ \hline
			sar			& Arithmetic Shift Right	& 0x9 \\ \hline
			sll			& Logic Shift Left			& 0xa \\ \hline
			slr			& Logic Shift Right			& 0xb \\ \hline
			comp		& Compare					& 0xc \\ \hline
			Reserved	& n/a						& 0xd \\ \hline
			Reserved	& n/a						& 0xe \\ \hline
			Reserved	& n/a						& 0xf \\ \hline

%	\end{tabular} \\
\end{longtable}
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}

\newpage
\subsubsection{Immediate}

\begin{center}
		\begin{tabular}{|c|c|c|c|c|}
			\multicolumn{5}{c}{Immediate Instruction Format}\\ \hline
				\hspace{2pt} opcode \hspace{2pt} & \hspace{5pt} rd \hspace{5pt} &  \hspace{4pt} rsa \hspace{4pt} & \hspace{10pt}Immediate  \hspace{10pt} & \hspace{3pt} aluop \hspace{3pt}   \\	\hline
			31 \hfill 26& 25 \hfill 21 &20 \hfill  16& 15  \hfill   4&3 \hfill   0\\ \hline
		
	\end{tabular}
\end{center}
\paragraph{Overview:}The Immediate Instruction Format is for ALU operations that require an immediate value. The immediate field
is only 12 bits wide, so in the event that a larger value is required, the Load Immediate Format should be used. There is only a single
source register, RSa, with the other source being the immediate value. The result is stored into register Rd.
\paragraph{}The following instructions use this encoding:
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
			Instruction & Description 						& ALU Operation (hex) \\ \hline
			addi		& Add Immediate						& 0x0 \\ \hline
			subi 		& Subtract Immediate				& 0x1 \\ \hline
			addui 		& Add Unsigned Immediate			& 0x2 \\ \hline
			subui		& Subtract Immediate Immediate 	& 0x3 \\ \hline
			andi		& And Immediate						& 0x5 \\ \hline
			ori			& Or Immediate						& 0x6 \\ \hline
			xori		& Exclusive Or Immediate			& 0x7 \\ \hline
			sali		& Arithmetic Shift Left				& 0x8 \\ \hline
			sari		& Arithmetic Shift Right			& 0x9 \\ \hline
			slli		& Logic Shift Left 					& 0xa \\ \hline
			slri		& Logic Shift Right					& 0xb \\ \hline
			compi		& Compare Immedaite					& 0xc \\ \hline

	\end{tabular} \\
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}

\newpage
\subsubsection{Load/Store}
\begin{center}
		\begin{tabular}{|c|c|c|c|c|}
			\multicolumn{5}{c}{Load Instruction Format}\\ \hline
				\hspace{2pt} opcode \hspace{2pt} & \hspace{5pt} rd \hspace{5pt} &  \hspace{4pt} rsa \hspace{4pt} & \hspace{3pt} funct \hspace{3pt} & \hspace{10pt} Immediate \hspace{10pt}   \\	\hline
				31 \hfill 26& 25 \hfill 21 &20 \hfill  16& 15 \hfill 14  & 13 \hfill 0\\ \hline
		
	\end{tabular}
\end{center}
\paragraph{Overview:}The Load Instruction Format is for reading values from memory into a register. A 14 bit immediate is used
for a relative address calculation with RSa as the base address. The value is then stored into register Rd. The funct field is used
to determine the byte size to read from memory. This encoding is described in the table below. \\
\begin{tabular}{l|l}
		Funct & Description \\ \hline
		00	  & 1 word (32 bits) \\
		01	  & half word (16 bits, upper) \\ 
		10	  & 24 bits, upper \\
		11	  & byte, upper		\\
		\end{tabular}
\paragraph{}The following instructions use this encoding: \\
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
			Instruction & Description 						& Funct\\ \hline
			lw			& Load Word							& 0x0 \\ \hline
			lh			& Load Half Word					& 0x1 \\ \hline
			lb			& Load Byte							& 0x3 \\ \hline
			lth			& Load Three (Bytes, 24 bits)		& 0x2 \\ \hline

\end{tabular}
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}

\begin{center}
		\begin{tabular}{|c|c|c|c|}
				\multicolumn{4}{c}{Load Immediate Instrution Format}\\ \hline
				\hspace{2pt} opcode \hspace{2pt} & \hspace{5pt} rd \hspace{5pt} &  \hspace{4pt} DSEL \hspace{4pt} & \hspace{10pt}Immediate  \hspace{10pt}   \\	\hline
			31 \hfill 26& 25 \hfill 21 &20 \hfill  16& 15  \hfill   0\\ \hline
		
	\end{tabular}
\end{center}

\paragraph{Overview:}The Load Immediate Instruction Format is for loading immeidate values into a register.
The DSEL value determines the destination and function of the instruction. This is to allow the selection
of various register files to be updated. THe DSEL bit values and their function are shown below. 
The MSB of DSEL determines if the value is unsigned (1) or signed (0). \\
\begin{tabular}{l|l}
		DSEL (bin) & Destination \\ \hline
		0000 & General purpose register file \\
		0001 & System Register File \\
		0010 & Global Co-Processor Register File \\ 
		0011 & General purpose register file (upper 16 bits) \\
		0100 & System Register File (upper 16 bits)\\
		0101 & Global Co-Processor Register File (upper 16 bits)\\ 
		1000 & General purpose register file  (Unsigned)\\
		1001 & System Register File (Unsigned)\\
		1010 & Global Co-Processor Register File (Unsigned)\\ 
		1011 & General purpose register file  (Unsigned, upper 16 bits)\\
		1100 & System Register File (Unsigned, upper 16 bits)\\
		1101 & Global Co-Processor Register File (Unsigned, upper 16 bits)\\ 
		
		\end{tabular}

\paragraph{}The following instructions use this encoding: \\
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
			Instruction & Description 								& DSEL\\ \hline
			li			& load immediate (gprf)						& 0x0 \\ \hline
			lsi			& load immediate system						& 0x1 \\ \hline
			lgi			& load immediate global						& 0x2 \\ \hline
			lui			& load immediate (gprf)	(upper)				& 0x3 \\ \hline
			lusi		& load immediate system	(upper)				& 0x4 \\ \hline
			lugi		& load immediate global	(upper)				& 0x5 \\ \hline
			lni			& load immediate (gprf)	(unsigned)			& 0x8 \\ \hline
			lnsi		& load immediate system	(unsigned)			& 0x9 \\ \hline
			lngi		& load immediate global	(unsigned)			& 0xa \\ \hline 
			luni		& load immediate (gprf) (unsigned,upper)	& 0xb \\ \hline
			lunsi		& load immediate system	(unsigned,upper		& 0xc \\ \hline
			lungi		& load immediate global	(unsigned,upper)	& 0xd \\ \hline

\end{tabular}
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}


\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
			\multicolumn{6}{c}{Store Instruction Format}\\ \hline
				\hspace{2pt} opcode \hspace{2pt} & \hspace{5pt} Funct \hspace{5pt} &  \hspace{4pt} Immediate[13:11] \hspace{4pt} & \hspace{4pt}rsa  \hspace{4pt} & \hspace{4pt}rsb  \hspace{4pt} &\hspace{10pt}Immediate[10:0]  \hspace{10pt}     \\	\hline
				31 \hfill 26& 25 \hfill 24 &23 \hfill 21 &20 \hfill  16& 15 \hfill  11&10 \hfill  0\\ \hline
		
	\end{tabular}
\end{center}
\paragraph{Overview:}The Store Instruction Format is for writing register values to memory. A 14 bit immediate is used
for a relative address calculation with RSa as the base address. The value in RSb is then written to memory. The funct field is used
to determine the byte size to write to memory. This encoding is described in the table below. \\
\begin{tabular}{l|l}
		Funct & Description \\ \hline
		00	  & 1 word (32 bits) \\
		01	  & half word (16 bits, upper) \\ 
		10	  & 24 bits, upper \\
		11	  & byte, upper		\\
		\end{tabular}
\paragraph{}The following instructions use this encoding: \\
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
			Instruction & Description 						& Funct\\ \hline
			sw			& Store Word							& 0x0 \\ \hline
			sh			& Store Half Word					& 0x1 \\ \hline
			sb			& Store Byte							& 0x3 \\ \hline
			sth			& Store Three (Bytes, 24 bits)		& 0x2 \\ \hline

\end{tabular}
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}

\newpage
\subsubsection{Branch/Jump}

\begin{center}
		\begin{tabular}{|c|c|c|c|}
				\multicolumn{4}{c}{Jump Instruction Format}\\ \hline
				\hspace{2pt} opcode \hspace{2pt}  & \hspace{3pt} Immediate[20:16] \hspace{3pt} &  \hspace{4pt} rsa \hspace{4pt} & \hspace{10pt} Immediate[15:0]  \hspace{10pt}   \\	\hline
							31 \hfill 26& 25  \hfill 21 &20 \hfill  16& 15 \hfill   0\\ \hline
		
	\end{tabular}
\end{center}	
\paragraph{Overview:} The Jump Instruction format is for changing the Program Counter. 
All Jumps are relative, except Jump Register Instructions,
due to the non byte aligned size (20 bits) of the immediate field. Jumps use the value in register RSa to calculate
the new PC. For pure relative jumps, the Zero register is used as the base. For jump instructions that link the program counter, 
the PC is stored in RA0, or R4 in the General Purpose Register file.
\paragraph{}The following instructions use this encoding: \\
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
			Instruction & Description 				\\ \hline
			j			& Jump						\\ \hline
			jal			& Jump and Link				\\ \hline
			jr			& Jump Register				\\ \hline
			jrl			& Jump Register and Link	\\ \hline


\end{tabular}
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}


\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
			\multicolumn{6}{c}{Branch Instruction Format}\\ \hline
				\hspace{2pt} opcode \hspace{2pt} & \hspace{5pt} Immediate[13:9] \hspace{5pt} &  \hspace{4pt} rsa \hspace{4pt} & \hspace{4pt}rsb  \hspace{4pt}& \hspace{10pt}Immediate[8:0]  \hspace{10pt} & \hspace{3pt} funct \hspace{3pt}   \\	\hline
			31 \hfill 26& 25 \hfill 21 &20 \hfill  16& 15 \hfill  11&10 \hfill   2&1 \hfill   0\\ \hline
		
	\end{tabular}
\end{center}
\paragraph{Overview:} The Branch Instruction Format is used for conditionally changing the Program Counter.
The PC is only updated with whichever operation is indicated as being true or false.\\
\paragraph{}The following instructions use this encoding: \\
\begin{center}
	\begin{tabular}{|l|l|l|} \hline
			Instruction & Description 				& Funct\\ \hline
			beq			& Branch if Equal			& 00 \\ \hline
			bne			& Branch if not Equal		& 01 \\ \hline
			bgt			& Branch if Greater than	& 10 \\ \hline
			blt			& Branch if Less than		& 11 \\ \hline

\end{tabular}
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}

\newpage
\subsubsection{System Instructions}
\begin{center}
	\begin{tabular}{|c|c|c|c|c|}
		\multicolumn{5}{c}{System Instruction Format}\\ \hline
			\hspace{2pt} opcode \hspace{2pt} & \hspace{5pt} rd \hspace{5pt} &  \hspace{4pt} rsa \hspace{4pt} & \hspace{10pt}Funct  \hspace{10pt} & \hspace{8pt} Immediate[7:0] \hspace{8pt}   \\	\hline
		31 \hfill 26& 25 \hfill 21 &20 \hfill  16& 15 \hfill  8&7 \hfill   0\\ \hline
		
	\end{tabular}
\end{center}
\paragraph{Overview:} The System Instruction Format is used for various system controls. Their functions
vary, and are described in more detail in their individual listings.
\paragraph{}The following instructions use this encoding: \\
\begin{center}
	\begin{tabular}{|l|l|l|l|} \hline
			Instruction & Description 						& Funct & Uses Immediate\\ \hline
			syscall		& System Call						& 0x00  & yes \\ \hline
			sysret		& System Return						& 0x01  & no  \\ \hline
			stspr		& Store Special Purpose Register	& 0x02  & yes \\ \hline
			ldspr		& Load Special Purpose Register		& 0x03  & yes \\ \hline
			sync		& Syncronize memory/Flush Pipeline  & 0x04  & no  \\ \hline
			lock		& Lock Memory						& 0x05  & yes \\ \hline
			test		& Test Lock 						& 0x06  & yes \\ \hline
			pmir		& Permission Increase Request		& 0x07  & yes \\ \hline
			pmd			& Permission Decrease				& 0x08  & yes \\ \hline


\end{tabular}
\end{center}
\begin{center}
	\line(1,0){250}
\end{center}
\newpage
\subsubsection{Co-Processor}

\paragraph{}Since the coprocessors can have any implementation, only the opcode is required. However, adhering to similar formatting of the instruction formats provided in previous sections is imperative and the Fusion-Core foundation will not provide an accepted coprocessor ID number. More information about coprocessors can be accessed in the Co-Processor section.
\begin{center}
	\line(1,0){250}
\end{center}

\newpage
\subsection{List of OPCodes}
	\begin{center}
		\begin{tabular}{|c|c|c|}
			Op Code & Description & Instrucion Formats \\ \hline
		\end{tabular}
	\end{center}

\newpage
\subsection{Instruction Details}
\paragraph{}This section will go into detail about the instructions that are available, with their functions and options.\\
\subsubsection{Integer}

\subsection{List of Instructions}

	\begin{center}
		\begin{longtable}{|l|l|c|}
			\multicolumn{3}{c}{Instruction Instruction Summary Table} \\ \hline
			\multicolumn{3}{|c|}{Integer Instructions} \\ \hline
			Instruction & Function 										& Binary \\ \hline
			add			& Rd = RSa + RSb 								& 000001dddddaaaaabbbbbxxxxxxx0000 \\
			sub			& Rd = RSa - RSb 								& 000001dddddaaaaabbbbbxxxxxxx0001 \\
			addu		& Rd = RSa + RSb (Unsigned) 					& 000001dddddaaaaabbbbbxxxxxxx0010 \\
			subu		& Rd = RSa - RSb (Unsigned)					 	& 000001dddddaaaaabbbbbxxxxxxx0011 \\
			tcmp		& Rd = !Rsa	 									& 000001dddddaaaaaxxxxxxxxxxxx0100 \\
			and			& Rd = RSa \& RSb								& 000001dddddaaaaabbbbbxxxxxxx0101 \\
			or			& Rd = RSa $|$ RSb 								& 000001dddddaaaaabbbbbxxxxxxx0110 \\
			xor			& Rd = RSa $\oplus$ RSb 						& 000001dddddaaaaabbbbbxxxxxxx0111 \\
			sal			& Rd = RSa $\ll$ RSb 							& 000001dddddaaaaabbbbbsssssss1000 \\
			sar			& Rd = RSa $\gg$ RSb 							& 000001dddddaaaaabbbbbsssssss1001 \\
			sll			& Rd = RSa $\ll$ RSb 							& 000001dddddaaaaabbbbbsssssss1010 \\
			slr			& Rd = RSa $ \ggg  $ RSb 						& 000001dddddaaaaabbbbbsssssss1011 \\
			comp		& Rd = (RSa == RSb);(RSa $>$ RSb);(RSa $<$ Rsb)	& 000001dddddaaaaaxxxxxsssssss1100 \\
			\hline
			\multicolumn{3}{|c|}{Immediate Instructions} \\ \hline
			addi		& Rd = RSa + Imm 								& 000011dddddaaaaaiiiiiiiiiiii0000 \\
			subi		& Rd = RSa - Imm 								& 000011dddddaaaaaiiiiiiiiiiii0001 \\
			addui		& Rd = RSa + Imm (Unsigned)						& 000011dddddaaaaaiiiiiiiiiiii0010 \\
			subui		& Rd = RSa - Imm (Unsigned)					 	& 000011dddddaaaaaiiiiiiiiiiii0011 \\
			andi		& Rd = RSa \& Imm								& 000011dddddaaaaaiiiiiiiiiiii0101 \\
			ori			& Rd = RSa $|$ Imm 								& 000011dddddaaaaaiiiiiiiiiiii0110 \\
			xori		& Rd = RSa $\oplus$ Imm 						& 000011dddddaaaaaiiiiiiiiiiii0111 \\
			sali		& Rd = RSa $\ll$ Imm 							& 000011dddddaaaaaiiiiiiiiiiii1000 \\
			sari		& Rd = RSa $\gg$ Imm 							& 000011dddddaaaaaiiiiiiiiiiii1001 \\
			slli		& Rd = RSa $\ll$ Imm 							& 000011dddddaaaaaiiiiiiiiiiii1010 \\
			slri		& Rd = RSa $ \ggg  $ Imm 						& 000011dddddaaaaaiiiiiiiiiiii1011 \\
			compi		& Rd = (RSa == Imm);(RSa $>$ Imm);(RSa $<$ Imm)	& 000011dddddaaaaaiiiiiiiiiiii1100 \\
			\hline
			\multicolumn{3}{|c|}{Load Instructions} \\ \hline
			lw			& Rd $<$- Imm(RSa)								& 010010dddddaaaaa00iiiiiiiiiiiiii \\
			lh			& Rd $<$- Imm(RSa)								& 010010dddddaaaaa01iiiiiiiiiiiiii \\
			lb			& Rd $<$- Imm(RSa)								& 010010dddddaaaaa11iiiiiiiiiiiiii \\
			lth			& Rd $<$- Imm(RSa)								& 010010dddddaaaaa10iiiiiiiiiiiiii \\
			\hline
			\multicolumn{3}{|c|}{Load Immediate Instructions} \\ \hline
			li			& (GPREGF) Rd = Imm								& 000010ddddd0000iiiiiiiiiiiiiiiii \\
			lsi			& (SYSREGF) Rd = Imm							& 000010ddddd0001iiiiiiiiiiiiiiiii \\
			lgi			& (GLREGF) Rd = Imm								& 000010ddddd0010iiiiiiiiiiiiiiiii \\
			\hline
			Instruction & Function 										& Binary \\ \hline
			lui			& (GPREGF) Rd = Imm	(upper 16 bits)				& 000010ddddd0011iiiiiiiiiiiiiiiii \\
			lusi		& (SYSREGF) Rd = Imm (upper 16 bits)			& 000010ddddd0100iiiiiiiiiiiiiiiii \\
			lugi		& (GLREGF) Rd = Imm	 (upper 16 bits)			& 000010ddddd0101iiiiiiiiiiiiiiiii \\
			lni			& (GPREGF) Rd = Imm	(unsigned)					& 000010ddddd1000iiiiiiiiiiiiiiiii \\
			lnsi		& (SYSREGF) Rd = Imm (unsigned)					& 000010ddddd1001iiiiiiiiiiiiiiiii \\
			lngi		& (GLREGF) Rd = Imm (unsigned)					& 000010ddddd1010iiiiiiiiiiiiiiiii \\
			luni		& (GPREGF) Rd = Imm	 (upper 16, unsigned)		& 000010ddddd1011iiiiiiiiiiiiiiiii \\
			lunsi		& (SYSREGF) Rd = Imm (upper 16, unsigned)		& 000010ddddd1100iiiiiiiiiiiiiiiii \\
			lungi		& (GLREGF) Rd = Imm	(upper 16, unsigned)		& 000010ddddd1101iiiiiiiiiiiiiiiii \\
			\hline
			\multicolumn{3}{|c|}{Store Instructions} \\ \hline

			sw			& RSb -$>$ Imm(RSa)								& 01101000iiiaaaaabbbbbiiiiiiiiiii\\
			sh			& RSb -$>$ Imm(RSa)								& 01101001iiiaaaaabbbbbiiiiiiiiiii\\
			sb			& RSb -$>$ Imm(RSa)								& 01101011iiiaaaaabbbbbiiiiiiiiiii\\
			sth			& RSb -$>$ Imm(RSa)								& 01101010iiiaaaaabbbbbiiiiiiiiiii\\
			\hline
			\multicolumn{3}{|c|}{Jump Instructions} \\ \hline		
			j			& Next PC $<$- (R0 + Imm)						& 000110iiiiiaaaaaiiiiiiiiiiiiiiii\\
			jal			& Next PC $<$- (R0 + Imm); RA0 <- PC 			& 000111iiiiiaaaaaiiiiiiiiiiiiiiii\\
			jr			& Next PC $<$- (RSa + Imm)						& 000110iiiiiaaaaaiiiiiiiiiiiiiiii\\
			jrl			& Next PC $<$- (RSa + Imm); RA0 <- PC			& 000111iiiiiaaaaaiiiiiiiiiiiiiiii\\
			\hline
			\multicolumn{3}{|c|}{Branch Instructions} \\ \hline
			beq			& Next PC $<$- (RSa == RSb) ? PC+Imm : PC+4		& 000101iiiiiaaaaabbbbbiiiiiiiii00\\
			bne			& Next PC $<$- (RSa != RSb) ? PC+Imm : PC+4		& 000101iiiiiaaaaabbbbbiiiiiiiii01\\
			bgt			& Next PC $<$- (RSa $>$ RSb) ? PC+Imm : PC+4	& 000101iiiiiaaaaabbbbbiiiiiiiii10\\
			blt			& Next PC $<$- (RSa $<$ RSb) ? PC+Imm : PC+4	& 000101iiiiiaaaaabbbbbiiiiiiiii11\\
			\hline
			\multicolumn{3}{|c|}{System Instructions} \\ \hline
			syscall		& System Call (Raise Privalege)					& 00100dddddaaaaaa00000000iiiiiiii\\
			sysret		& System Return (Lower Privalege)				& 00100dddddaaaaaa00000001iiiiiiii\\
			stspr		& (SYSRF) Rd $<$- RSa							& 00100dddddaaaaaa00000010xxxxxxxx\\
			ldspr		& (SYSRF) RSa -$>$ Rd							& 00100dddddaaaaaa00000011xxxxxxxx\\
			sync		& Flush Pipeline								& 00100xxxxxxxxxxx00000100xxxxxxxx\\
			pmir		& PML + Imm ?									& 00100xxxxxxxxxxx00000111iiiiiiii\\
			pmd			& PML - Imm ?									& 00100xxxxxxxxxxx00001000iiiiiiii\\
			\hline
		\end{longtable}
	\end{center}


\subsubsection{Immediate}
\subsubsection{Load/Store}
\subsubsection{Branch/Jump}
\subsubsection{Co-Processor}



\section{Exceptions and Interrupts}
\subsection{Exceptions}


\subsection{Interrupts}
\subsubsection{User Level}
\subsubsection{Supervisor Level}

\clearpage
\part{Co-Processors}
\section{Co-Processor Overview}
\paragraph{}Co-processors are the main point of the Fusion-Core archetecture. As the ISA only defines the main core, the implementator is free to use
whichever co-processors that would be necessary for an application. Hardware acceleration for vector instructions, encryption, floating point, communication,
etc. There is no limitation for what kind of co-processor that could be used, only the number that could fit within the defined usable instructions.
\paragraph{}It is important to note that the co-processors do not need to be of a RISC construction, due to this reliance on co-processors without
specifying how they should be implemented. The main core is indeed RISC, as only the simplest instructions are defined that something as small as a microcontroller
could use without issue.
\paragraph{}The idea behind the separation of processor is to create different pipelines for each core. In doing so, the main core could be clocked faster that of
a pipeline requiring integer multiplication, or some other time consuming operation. As well, the individual cores could be clocked at their respective 
fastest frequencies, thus resulting in the fastest possible performance of each part. To deal with writing to memory with varying clock speeds for each core,
a FIFO buffer is used to send each write to main memory. This FIFO is to create the illusion of write atomicity. The FIFO should have connections to allow
for a seeming atomic read though, the programmer should note that reads require care; if there is a dependancy on a slow core's written value. This programming 
paradigm is similar to that of parallel threads, where certain values may not be available until an unknown time. The ISA does not define any particular ways
to handle this and it is either left up to the implementation, or programmer depending.
\paragraph{}As shown in the instruction section, there are predefined regions for the co-processor slots. 
This is defined to allow for the compiler/assembler to work across implementations. At this time, only a fixed number of co-processors can be used on 
an implementation at a time, though future expansions to the ISA may change this.  

\subsection{Co-Processor Interface}
\paragraph{}The interface is designed to be extremely simple, as to make co-processors easy to implement. The inputs is just the output from the instruction fetch
passthrough on the decode unit. As shown in the instruction list, there is a section of 6 bits for the co-processor's opcode. Please also note
that this section of the instruction is different than the opcode , 0x3f (may change to 0x20 to allow for more opcodes for the co-processors) , which indicates that the instruction is for the co-processor. To save connections, 
the normal opcode section is removed, leaving 26 bit physical instructions. Using more bits per instruction is not supported at this time, though it is possible
to take the instruction fetch output directly. 
\subsubsection{Co-Processor Conventions}
\subsubsection{Register Connections}
\subsubsection{Decode unit Connections}
\subsection{Interface Connection Definitions}
\subsection{Adding custom Co-Processor}
\subsection{List of Co-Processors}
\subsubsection{Floating Point}
\subsubsection{System Unit}
\subsubsection{Memory Management Unit}
\subsubsection{Multiprocessor Communication Unit}

\section{Global Register File}
\paragraph{}The Global Register File is for simple message passing, and creating locks between co-processors.
As it may be necessary to wait for a value to be computed by a co-processor, or lock specific parts of memory,
the Global Register File creates an interface for ease of use between processing units.
\paragraph{}This section is under development and will be updated to explain the connections and registers available.

\section{Recommended Co-Processors}
\paragraph{About} This section will cover some basic coprocessors that have been approved and assigned coprocessor IDs. The full list of approved coprocessors will be included in a separate document. 
\subsection{Floating Point Unit}
\subsubsection{Registers}
\subsubsection{Instructions}
\subsection{System Unit}
\subsubsection{Registers}
\subsubsection{Instructions}
\subsection{Memory Management Unit}
\subsubsection{Registers}
\subsubsection{Instructions}
\subsection{Multiprocessor Communication Unit}
\subsubsection{Registers}
\subsubsection{Instructions}






\end{document}
